## ОП Python / 5. Объектно-ориентированное программирование в Python

### 5.1 Введение в ООП

**Объектно-ориентированное программирование** (ООП) - это стиль программирования, который основывается на использовании объектов, то есть некоторых абстрактных сущностей, которые представляют некоторые объекты или концепции в реальном мире. В Python есть множество возможностей для ООП.

Основные понятия ООП в Python:

- **Класс** - это шаблон для создания объектов. В классе определяются атрибуты (переменные, которые хранят данные) и методы (функции, которые могут менять данные или выполнять различные операции). Пример класса в Python:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def say_hello(self):
        print("Hello, my name is", self.name)
```
_Этот класс определяет человека с именем и возрастом, а также методом say_hello, который выводит приветствие и имя человека._

- **Объект** - это экземпляр класса. Когда вы создаете объект на основе класса, вы получаете экземпляр этого класса, который содержит все методы и атрибуты, определенные в классе. Например:

```python
person1 = Person("John", 30)
```

_Эта строка создает объект person1 на основе класса Person._

- **Атрибуты** - это данные, которые хранятся в объекте. В объекте класса Person выше имя и возраст являются атрибутами.

- **Методы** - это функции, которые определены в классе и могут менять данные объекта или выполнять другие операции. Например, в классе Person выше метод say_hello - это метод.

В Python объектно-ориентированное программирование может использоваться для решения широкого круга задач: от простых сценариев до сложных систем. За ним проще поддерживать и развивать, и его можно использовать для создания модулей, библиотек и приложений.

### 5.2 Классы и объекты в Python
Давайте более подробно остановимся на классах и объектах. Еще раз - Классы и объекты в Python используются для создания новых типов данных. Класс описывает структуру объекта, его свойства и методы, а объект является экземпляром класса.

Пример класса, описывающего студента:

```python
class Student:
    def __init__(self, name, age, grade):
        self.name = name
        self.age = age
        self.grade = grade
        
    def get_info(self):
        return f"{self.name} is {self.age} years old and is in grade {self.grade}."
```

_Ключевое слово `class` используется для создания нового класса. `__init__` - это метод, который вызывается при создании нового объекта класса. В примере он инициализирует атрибуты `name`, `age` и `grade`. Метод `get_info` используется для получения информации о студенте._

Пример использования класса:

```python
s = Student("Alice", 12, 6)
print(s.get_info())
```

_Этот код создает новый объект класса `Student` с именем `s`, используя переданные значения для атрибутов. Затем он вызывает метод `get_info`, который возвращает строку, описывающую студента._

Можно создать множество объектов класса с разными значениями атрибутов:

```python
s1 = Student("Bob", 11, 5)
s2 = Student("Charlie", 13, 7)
print(s1.get_info())
print(s2.get_info())
```

_Оба объекта `s1` и `s2` являются экземплярами класса `Student`. Каждый объект имеет свои собственные значения атрибутов, но все они имеют одни и те же методы._

Некоторые из основных принципов ООП в Python включают **наследование**, **инкапсуляцию** и **полиморфизм**. Наследование позволяет создавать новые классы на основе уже существующих классов. Инкапсуляция означает, что данные класса являются приватными, что означает, что они не могут быть изменены снаружи класса. Полиморфизм позволяет использовать методы и функции классов с одинаковыми именами, но с разными параметрами.

Также можно создавать подклассы (концепция - наследование), которые наследуют атрибуты и методы базового класса:

```python
class HighSchoolStudent(Student):
    def get_info(self):
        return f"{self.name} is a high school student in grade {self.grade}."
```

_Этот подкласс `HighSchoolStudent` наследует все атрибуты и методы класса `Student`, но переопределяет метод `get_info`, чтобы добавить информацию о том, что это старшеклассник. _

Пример использования подкласса:

```python
h = HighSchoolStudent("David", 16, 10)
print(h.get_info())
```

_Этот код создает новый объект подкласса `HighSchoolStudent` с именем `h`, используя переданные значения для атрибутов. Затем он вызывает переопределенный метод `get_info`, который возвращает строку, описывающую старшеклассника. _

В Python классы и объекты используются часто и широко, и являются одним из основных инструментов ООП в языке программирования Python.
### 5.3 Наследование и полиморфизм
Наследование и полиморфизм - это ключевые понятия в объектно-ориентированном программировании (ООП). Оба понятия описывают способы повторного использования кода и являются важными для создания эффективных и гибких программ.

Наследование - это механизм, при котором новый класс создается на основе существующего класса. Новый класс наследует свойства и методы от родительского класса и может добавлять свои собственные свойства и методы. Наследование позволяет создавать новые классы на основе уже существующих, что упрощает их создание и снижает затраты на разработку.

**Пример наследования:**

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("")

class Dog(Animal):
    def speak(self):
        print("woof")
```

_Класс Dog наследует свойства и методы класса Animal, и добавляет свой собственный метод speak, который переопределяет метод speak класса Animal._
Полиморфизм - это способность объектов разных классов использовать одни и те же методы или функции. Полиморфизм позволяет работать с объектами различных классов, не зная их конкретного типа.

**Пример полиморфизма:**

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "woof"

class Cat(Animal):
    def speak(self):
        return "meow"

def animal_speak(animal):
    print(animal.speak())

dog = Dog("Buddy")
cat = Cat("Fluffy")

animal_speak(dog)
animal_speak(cat)
```

_Функция animal_speak работает с объектами разных классов, но вызывает один и тот же метод speak, что является примером полиморфизма._

Разница между наследованием и полиморфизмом заключается в их целях. Наследование используется для повторного использования кода и создания новых классов на основе существующих, а полиморфизм используется для работы с объектами разных классов, но обладающих одинаковым интерфейсом методов.

(дополнительно)

**Пример класса с инкапсуляцией**

```python
class Person:
    def __init__(self, name, age):
        self.__name = name  # приватное свойство
        self.__age = age    # приватное свойство

    # геттер для имени
    def get_name(self):
        return self.__name

    # геттер для возраста
    def get_age(self):
        return self.__age

    # сеттер для имени
    def set_name(self, name):
        self.__name = name

    # сеттер для возраста
    def set_age(self, age):
        self.__age = age

# Создаем объект класса Person
person = Person("John", 25)

# Используем геттеры для получения значений приватных свойств
print(person.get_name())  # John
print(person.get_age())   # 25

# Используем сеттеры для изменения значений приватных свойств
person.set_name("Jack")
person.set_age(30)

# Проверяем, что значения были изменены
print(person.get_name())  # Jack
print(person.get_age())   # 30
```

### 5.4 Основные типы методов класса (статические, классовые..). Сторонние методы класса.
**5.4.1** Статические методы и методы класса - это особые методы в объектно-ориентированном программировании в языке Python. 

Статические методы должны определяться с помощью аннотации @staticmethod перед их определением внутри класса. Они могут вызываться с использованием имени класса вместо экземпляра класса, и обычно они не имеют доступа к атрибутам класса или экземпляра. Статические методы обычно используются как вспомогательные методы, которые не зависят от состояния объекта. 

Методы класса должны определяться с помощью аннотации @classmethod перед их определением внутри класса. Они могут получать аргумент cls вместо self, и имеют доступ к атрибутам класса, а не экземпляра. Методы класса используются для связывания данных с классом, а не с экземпляром. 

Кроме статических и методов класса, есть обычные методы, которые определяются без аннотаций @staticmethod или @classmethod. Они могут получать аргумент self и иметь доступ к атрибутам экземпляра. Обычные методы используются для работ с конкретным экземпляром класса. 

Для лучшего понимания и применения этих методов важно учитывать принципы ООП и контекст использования методов в данном классе.

**5.4.2** Примеры сторонних методов класса:
- __add__() - используется для добавления элементов в объект класса. Он принимает в качестве первого аргумента ссылку на сам объект класса и, как правило, вторым аргументом передается элемент, который нужно добавить.
Пример использования метода `add()` в классе `MySet`:

```python
class MySet:
    def __init__(self):
        self.elements = []

    def add(self, element):
        if element not in self.elements:
            self.elements.append(element)
```

_Здесь метод add() используется для добавления элементов в множество `MySet`. Сначала проверяется, не присутствует ли элемент уже в множестве, и если его там еще нет, то он добавляется при помощи метода `append()`._
- __str__() - метод, который представляет объект в виде строки при использовании функции str();
- __len__() - метод, который возвращает количество элементов в объекте;
- __getitem__() и __setitem__() - методы, которые позволяют получить или установить значение для элемента по индексу.

Например:

```python
class MyList:
    def __init__(self):
        self.elements = []

    def add(self, element):
        self.elements.append(element)

    def __str__(self):
        return str(self.elements)

    def __len__(self):
        return len(self.elements)

    def __getitem__(self, index):
        return self.elements[index]

    def __setitem__(self, index, value):
        self.elements[index] = value
```

Теперь мы можем создать объект класса `MyList`, добавить в него несколько элементов и работать с ними как с обычным списком Python:

```python
my_list = MyList()
my_list.add(10)
my_list.add(20)

print(my_list)  # вывод: [10, 20]
print(len(my_list))  # вывод: 2
print(my_list[0])  # вывод: 10

my_list[1] = 30
print(my_list)  # вывод: [10, 30]
```

В целом, методы классов в Python помогают удобно организовывать и работать с объектами данного класса, а также предоставляют удобный интерфейс для взаимодействия с ними.
