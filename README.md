## ОП Python / 6_stdata. Алгоритмы и структуры данных (АИСД) в Python.

### 6st.1. Анализ алгоритмов (оценка сложности алгоритмов и программы) 

**Анализ алгоритмов** - это как попытка понять, насколько быстро и сколько памяти занимает компьютер, чтобы выполнить определенную задачу. Представь себе, что ты играешь в гонки на велосипеде с другими людьми(соперниками). 
Как ты решаешь, кто быстрее? Ты смотришь на то, сколько времени нужно каждому, чтобы доехать до финиша, и кто приходит первым к этому финишу.

Точно так же и компьютеры **"соревнуются"** в выполнении задач. Мы можем оценить, какой из них справляется быстрее, изучив, сколько операций (вроде сложения, умножения и др) им нужно сделать, и сколько памяти они используют.

_Например_, давай представим, что у нас есть два способа сортировки списка чисел. Один способ может быть быстрее и использовать меньше памяти, чем др. Мы хотим понять, какой способ лучше. Для этого мы можем проанализировать оба алгоритма и узнать, какой из них более эффективен.
Такой анализ позволяет нам выбирать наиболее подходящие алгоритмы для наших задач и **улучшать производительность программ**.

Таким образом, **анализ алгоритмов** - это как выбор самого **быстрого** и **удобного** маршрута для выполнения задачи на компьютере. Что и помогает нам делать программы быстрее и эффективнее.

#### О-нотация
**О-нотация (также называемая "большое О" или "асимптотическая нотация")**- это способ описания того, как растет сложность алгоритма (или временная и пространственная сложность) в зависимости от размера входных данных. О-нотация помогает нам понять, насколько быстро или медленно алгоритм будет выполняться, когда мы увеличиваем размер входных данных. 

Наиболее распространенными обозначениями в О-нотации являются: 
| Вид О-нотации     | для чего                |
| ------------- |:------------------:|
| **О(1)**     | **константа** (постоянное время)    |
| **О(log n)**    | **логарифм** (логарифмич. время) |
| **О(n)** | **линейно** (линейное время)        |
| **О(n * log n)**    | **линейно - логарифмически** |
| **О(n^2)** | **квадратично** (квадратич. время)         |

Эти обозначения описывают, насколько быстро растет сложность алгоритма по сравнению с размером входных данных.

**Обычно на практике**, в порядке **увеличения эффективности**, алгоритмы стараются выбирать так, чтобы временная сложность была как можно ближе к O(1) или O(log n), так как это означает более эффективное выполнение задачи.

Пример кода (сумма элементов списка) - **О(n)**

```python
def sum_of_elements(lst):
    result = 0
    for element in lst:
        result += element
    return result
```

Определение временной сложности с использованием О-нотации:

    1. В данном случае, мы имеем цикл **for**, который проходит по всем элементам списка **lst** и складывает их.
    2. Кол-во операций в этом цикле зависит от размера списка **lst**, т.к цикл вып-ся один раз для каждого элемента в списке.
    3. Следовательно, временная сложность этой ф-ии - O(n), где n - это кол-во элементов в списке.

_Микровывод по примеру:_ время выполнения этой функции будет увел. **пропорционально кол-ву элементов** в списке. Если у нас есть 10 элементов, функция выполнит 10 операций; если у нас есть 100 элементов, функция выполнит 100 операций, и тд.

Пример кода (бинарный поиск) - **О(log n)**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1 
    return -1
```

Определение временной сложности с использованием О-нотации:

    1. В данном коде реализован бинарный поиск в отсортированном списке arr.
    2. В каждой итерации цикла while размер "поискового интервала" сокращается примерно в два раза, т.к мы сравниваем сред. элемент с target и исключаем половину элементов.
    3. Поэтому время выполнения этой функции - O(log n), где n - это кол-во элементов в списке.
    
_Микровывод по примеру:_ в бин. поиске время выполнения увел. не линейно с ростом размера списка, а **логарифмически**. Даже если список очень большой, бинарный поиск может быстро найти нужный элемент.

Пример кода (Сортировка пузырьком) - О(n^2)

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
```

Определение временной сложности с использованием О-нотации:

    1. Код реализует сортировку пузырьком, который работает путем многократного прохода по списку и сравнения соседних элементов.
    2. Внеш. цикл for i вып-ся n раз, где n - это количество элементов в списке.
    3. Внутр. цикл for j также вып-ся n раз для каждой итерации внешнего цикла.
    4. Это означает, что общее кол-во операций будет пропорционально n * n, что эквивалентно O(n^2).

_Микровывод по примеру:_ Сортировка пузырьком имеет **квадратичную временную сложность**, что делает ее медленной для больших списков.

Пример кода (Сортировка слияненим Merge) - О(n * log n)

```python
def merge_sort(arr):
  if len(arr) > 1:
      mid = len(arr) // 2
      left_half = arr[:mid]
      right_half = arr[mid:]

      merge_sort(left_half)
      merge_sort(right_half)

      i = j = k = 0

      while i < len(left_half) and j < len(right_half):
          if left_half[i] < right_half[j]:
              arr[k] = left_half[i]
              i += 1
          else:
              arr[k] = right_half[j]
              j += 1
          k += 1

      while i < len(left_half):
          arr[k] = left_half[i]
          i += 1
          k += 1

      while j < len(right_half):
          arr[k] = right_half[j]
          j += 1
          k += 1
```

Определение временной сложности с использованием О-нотации:

    1. Код реализует сортировку слиянием, которая разбивает список на две половины, сортирует их отдельно, а затем сливает отсортированные половины в один отсортированный список.
    2. Сортировка слиянием вып-ся рекурсивно, и каждый раз список делится пополам.
    3. В результате общее кол-во операций будет пропорционально n * log n, что эквивалентно O(n log n).

_Микровывод по примеру:_ Сортировка слиянием имеет **лучшую производительность** по сравнению с квадратичными сортировками (_например, сортировкой пузырьком_) для больших списков данных.

### 6st.2 Динамический массив данных

**Динамический массив** - это по факту контейнер или коробка, в которой ты можешь хранить элементы (например, числа или строки), и этот-же контейнер умеет увеличиваться, когда ты добавляешь в него больше элементов.
Две важные части динамического массива:

**Capacity (емкость)** - это, сколько элементов может вместить динамический массив, прежде чем ему нужно будет увеличить свой размер. Допустим, у нас есть коробка (динамический массив) с емкостью 6. Это значит, что мы можем в нее положить 6 элементов, но если мы попытаемся положить 7-й элемент, коробка автоматически увеличит свою емкость (на k-элементов), чтобы вместить его.

**Size (размер)** - это, сколько элементов действительно хранится в динамическом массиве. Например, если у нас есть коробка с емкостью 6 и внутри только 5 вещей, то размер равен 5.

![изображение](https://github.com/mrTester202/Python/assets/117897782/2a84f036-3f55-4264-a162-8411b30c6e97)

Важно помнить, что динамический массив увеличивает свою емкость автоматически, когда ему не хватает места для новых элементов. Это удобно, так как мы можем добавлять элементы в массив, не беспокоясь о том, исчерпаем ли мы его емкость.

В Python, **список (list)** явл-ся примером динамического массива. Ты можешь добавлять элементы в список, и его емкость будет увеличиваться по мере необходимости. Это делает работу с данными более гибкой и удобной.

### 6st.3 Хеш таблицы.

**Хеш-таблица** - это структура данных, которая позволяет хранить данные в виде пары **"ключ-значение"**. Она работает по принципу быстрого доступа к данным по ключу. В Python, хеш-таблицы реализованы в виде **словарей (dictionaries)**.

**Ключ** - это уникальный идентификатор, который помогает найти значение в хеш-таблице. Например, если у нас есть хеш-таблица, представляющая телефонную книгу, то имена людей могут быть ключами, а их номера телефонов - значениями.

**Хеш-функция** - это функция, которая преобразует ключ в числовое значение (хеш-код). Хеш-код используется для быстрого поиска соответствующего значения. Хорошая хеш-функция должна быть быстрой и равномерно распределять хеш-коды для разных ключей.

![HASHTB12 svg](https://github.com/mrTester202/Python/assets/117897782/9320dd2c-841b-46b0-b347-2cb7ed22104d)


Теперь о коллизиях. Коллизия происходит, когда **два разных ключа дают одинаковый хеш-код**. Например, если два человека имеют одинаковое имя в телефонной книге, у них будет одинаковый ключ, но разные номера телефонов.

_Решение коллизий:_

**Метод цепочек (Chaining)**: - метод заключается в том, чтобы каждую "ячейку" хеш-таблицы сделать как бы мини-списком (или другой структурой данных). Если есть коллизия, то новое значение просто добавляется в соответствующий мини-список. Поиск элемента осуществляется сначала по хеш-коду ключа, а затем внутри мини-списка.

**Открытая адресация (Open Addressing)** - здесь, если произошла коллизия, то новый элемент ищет другое место внутри самой хеш-таблицы на основе какого-либо правила (например, простое линейное пробирование - поиск следующей доступной ячейки). Этот процесс продолжается до тех пор, пока не будет найдено свободное место.

Пример кода.

```python
class HashTable:
    def __init__(self, size):
        self.size = size  # Размер хеш-таблицы
        self.table = [None] * size  # Создаем пустую таблицу заданного размера

    def _hash(self, key):
        """
        Приватный метод для вычисления хеш-кода ключа.
        """
        return hash(key) % self.size

    def insert(self, key, value):
        """
        Вставка элемента по ключу.
        """
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            # Если в данной ячейке уже есть элементы,
            # добавляем новый элемент в конец списка
            self.table[index].append((key, value))

    # остальные методы ...

hash_table = HashTable(10)  # Создаем хеш-таблицу размером 10
hash_table.insert("apple", 5)
hash_table.insert("banana", 2)
hash_table.insert("cherry", 8)
print(hash_table.get("apple"))  # Вывод: 5
print(hash_table.get("cherry"))  # Вывод: 8
hash_table.remove("banana")
print(hash_table.get("banana"))  # Вывод: None, так как элемент удален
```

Таким образом, хеш-таблицы позволяют быстро находить значения по ключу, а методы решения коллизий обеспечивают надежное хранение данных в случае, если разные ключи дадут одинаковые хеш-коды.

### 6st.4 Деревья. Бинарные деревья.

Бинарное дерево - это структура данных, которая состоит из узлов (вершин) и рёбер, связывающих эти узлы. В бинарном дереве каждый узел может иметь не более двух дочерних узлов: левого и правого. Это означает, что каждый узел может быть связан с максимум двумя другими узлами.

Основные компоненты бинарного дерева:

**Корень (root)** - это вершина дерева, из которой начинаются все пути вниз по дереву. У корня нет родителей.

**Узлы (nodes)** - это элементы дерева, которые содержат данные и имеют ноль, один или два дочерних узла.

**Листья (leaves)** - это узлы, которые не имеют дочерних узлов, то есть они находятся в самом нижнем уровне дерева.

**Родители и дети** - узел, из которого выходит ребро, называется "родителем", и узлы, соединенные этим ребром, называются "детьми".

**Уровень (level)** - уровень узла определяется количеством рёбер между корнем и этим узлом. Корень находится на уровне 0, его дети на уровне 1, и так далее.

**Глубина (depth)** - глубина узла - это количество рёбер от корня до этого узла.

**Поддерево (subtree)** - часть дерева, включая узел и всех его потомков, называется поддеревом.

![tree](https://github.com/mrTester202/Python/assets/117897782/50dbe073-afb8-48e7-987d-42acf4591a09)

в данном примере A - root корень дерева. В и C поддеревья корня A. 

Бинарные деревья могут исп-ся для решения различных задач, таких как поиск, сортировка и многие другие. Они также служат основой для других видов деревьев, таких как двоичные поисковые деревья (Binary Search Trees, BST) и деревья куч (Binary Heaps), которые имеют свои собственные особенности и применения.

Пример кода.

```python
class TreeNode:
    """класс узла дерева"""
    def __init__(self, key):
        self.left = None # левый потомок
        self.right = None # правый потомок
        self.val = key # значение в узле

class BinaryTree:
    """класс бинарное дерево"""
    def __init__(self):
        self.root = None # корень дерева

    def insert(self, key):
        if self.root is None:
            self.root = TreeNode(key)
        else:
            self._insert_recursively(self.root, key)

    def _insert_recursively(self, current_node, key):
        if key < current_node.val:
            if current_node.left is None:
                current_node.left = TreeNode(key)
            else:
                self._insert_recursively(current_node.left, key)
        else:
            if current_node.right is None:
                current_node.right = TreeNode(key)
            else:
                self._insert_recursively(current_node.right, key)

    def search(self, key):
        return self._search_recursively(self.root, key)

    def _search_recursively(self, current_node, key):
        if current_node is None or current_node.val == key:
            return current_node
        if key < current_node.val:
            return self._search_recursively(current_node.left, key)
        return self._search_recursively(current_node.right, key)

# Пример использования
if __name__ == "__main__":
    tree = BinaryTree()
    tree.insert(5)
    tree.insert(3)
    tree.insert(8)
    tree.insert(1)
    tree.insert(4)

    # Поиск элемента в дереве
    result = tree.search(4)
    if result:
        print
```

Добавление элемента в бинарное дерево происходит путем поиска подходящей позиции для нового элемента в дереве и вставки его там. Процесс добавления элемента можно разбить на несколько шагов:

**Начало с корня:** Начинаем с корневого узла бинарного дерева.

**Сравнение ключа:** Сравниваем ключ нового элемента с ключом текущего узла.

**Определение направления:** Если ключ нового элемента меньше ключа текущего узла, то двигаемся влево (к левому поддереву); если больше или равен, то двигаемся вправо (к правому поддереву).

**Повторение:** Повторяем шаги 2 и 3 для текущего узла, пока не найдем пустое место, где можно вставить новый элемент.

**Вставка:** Когда достигнуто пустое место (нет дочерних узлов), вставляем новый узел там.

**Бинарное дерево** и **бинарное дерево поиска (BST)** - это две разные структуры данных, хотя обе они представляют собой деревья, состоящие из узлов, связанных между собой. 

**Бинарное дерево поиска** также является бинарным деревом, но оно предназначено для хранения данных так, чтобы операции поиска, вставки и удаления были эффективными. Главной целью BST является упорядоченное хранение данных с возможностью быстрого поиска. В **BST** данные упорядочены таким образом, что для каждого узла все значения в левом поддереве меньше или равны значению узла, а все значения в правом поддереве больше. Это упорядочение обеспечивает эффективные операции поиска, вставки и удаления.

**BST** широко исп-ся для реализации структур данных, таких как словари, множества и ассоциативные массивы. Они позволяют эффективно выполнять операции поиска, вставки и удаления, и их упорядоченность данных имеет практическое применение.

**BST дерево:**
![1-sample-BST](https://github.com/mrTester202/Python/assets/117897782/b8aae7c8-836f-4d9c-b5c4-a126cb88c05b)

Пример кода

```python
class TreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        self.root = self._insert_recursively(self.root, key)

    def _insert_recursively(self, root, key):
        if root is None:
            return TreeNode(key)
        if key < root.val:
            root.left = self._insert_recursively(root.left, key)
        else:
            root.right = self._insert_recursively(root.right, key)
        return root

    def search(self, key):
        return self._search_recursively(self.root, key)

    def _search_recursively(self, root, key):
        pass

# остальные методы класса

if __name__ == "__main__":
    bst = BinarySearchTree()
    bst.insert(50)
    bst.insert(30)
    bst.insert(70)
    bst.insert(20)
    bst.insert(40)
    bst.insert(60)
    bst.insert(80)

    # Поиск элемента в дереве
    result = bst.search(60)
    if result:
        print("Элемент найден:", result.val)
    else:
        print("Элемент не найден")

    # Удаление элемента из дерева
    bst.delete(30)
    print("После удаления 30:")
    result = bst.search(30)
    if result:
        print("Элемент найден:", result.val)
    else:
        print("Элемент не найден")
```
